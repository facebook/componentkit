(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{79:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",function(){return c}),n.d(t,"rightToc",function(){return l}),n.d(t,"default",function(){return d});n(0);var a=n(135);function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c={title:"Basics"},l=[{value:"Setup",id:"setup",children:[]},{value:"Add/Modify content in the collection view",id:"addmodify-content-in-the-collection-view",children:[]},{value:"Handle actions",id:"handle-actions",children:[]}],r={rightToc:l},s="wrapper";function d(e){var t=e.components,n=i(e,["components"]);return Object(a.b)(s,o({},r,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"In this section we will go through the steps to create a ",Object(a.b)("inlineCode",{parentName:"p"},"UICollectionView")," powered by components."),Object(a.b)("p",null,"We will use a simple setup with a ",Object(a.b)("inlineCode",{parentName:"p"},"UIViewController")," using a ",Object(a.b)("inlineCode",{parentName:"p"},"UICollectionView")," that uses a ",Object(a.b)("inlineCode",{parentName:"p"},"UICollectionViewFlowLayout"),"."),Object(a.b)("h3",null,Object(a.b)("a",o({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"setup"})),Object(a.b)("a",o({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#setup"}),"#"),"Setup"),Object(a.b)("h4",null,Object(a.b)("a",o({parentName:"h4"},{"aria-hidden":!0,className:"anchor",id:"component-provider"})),Object(a.b)("a",o({parentName:"h4"},{"aria-hidden":!0,className:"hash-link",href:"#component-provider"}),"#"),"Component Provider"),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"CKCollectionViewDataSource")," is responsible for transforming each model into a component."),Object(a.b)("p",null,"This transformation will be defined as a method on a class conforming to ",Object(a.b)("inlineCode",{parentName:"p"},"CKComponentProvider"),". This class will then be passed to the ",Object(a.b)("inlineCode",{parentName:"p"},"CKCollectionViewDataSource")," as the component provider and the datasource will call the provider every time it needs to generate a component for a model."),Object(a.b)("p",null,"Let's make our UIViewController be the component provider here."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-objectivec"}),"@interface MyController <CKComponentProvider>\n...\n@end\n\n@implementation MyController\n...\n+ (CKComponent *)componentForModel:(MyModel*)model context:(MyContext*)context {\n    return [MyComponent newWithModel:model context:context];\n}\n...\n")),Object(a.b)("div",{class:"note-important"},Object(a.b)("p",null,"This class method has to be pure and thread safe.")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Why use a class Method and not a block?")," The model to component transform should not rely on mutable state. Blocks make it very easy to capture mutable state that could introduce side effects in the system. Using a class method allows to better enforce the constraint of immutability from an API standpoint."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"What is this context ?")," The context is an arbitrary immutable object, that is passed to this method by the ",Object(a.b)("inlineCode",{parentName:"li"},"CKCollectionViewDataSource"),". Typically, the context can be used to pass into your component tree:\n",Object(a.b)("em",{parentName:"li"}," immutable contextual informations such as the type of device.\n")," external dependencies such as an image downloader.")),Object(a.b)("div",{class:"note-important"},Object(a.b)("p",null,"Don't access global state inside a Component. Use the context to pass this information instead.")),Object(a.b)("h4",null,Object(a.b)("a",o({parentName:"h4"},{"aria-hidden":!0,className:"anchor",id:"create-a-ckcollectionviewdatasource"})),Object(a.b)("a",o({parentName:"h4"},{"aria-hidden":!0,className:"hash-link",href:"#create-a-ckcollectionviewdatasource"}),"#"),"Create a ",Object(a.b)("inlineCode",{parentName:"h4"},"CKCollectionViewDataSource")),Object(a.b)("p",null,"Ok, so now we have our view controller as the component provider, let's create our ",Object(a.b)("inlineCode",{parentName:"p"},"CKCollectionViewDataSource")," and attach the collection view to it."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-objectivec"}),"- (void)viewDidLoad {\n[super viewDidLoad];\n...\n\n// Range provider\n_sizeRangeProvider = [CKComponentFlexibleSizeRangeProvider providerWithFlexibility:CKComponentSizeRangeFlexibleHeight];\nconst CKSizeRange sizeRange = [_sizeRangeProvider sizeRangeForBoundingSize:self.collectionView.bounds.size];\n\n// Data source configuration\nCKDataSourceConfiguration *configuration =\n[[CKDataSourceConfiguration alloc] initWithComponentProviderFunc:ComponentProvider context:context sizeRange:sizeRange];\n// Data source                       \n_dataSource = [[CKCollectionViewDataSource alloc] initWithCollectionView:self.collectionView supplementaryViewDataSource:nil configuration:configuration];\n")),Object(a.b)("p",null,"Note that we pass the context in the initializer. It is the same context that will get passed into ",Object(a.b)("inlineCode",{parentName:"p"},"+ (CKComponent *)componentForModel:context:")," every time a component needs to be computed."),Object(a.b)("h3",null,Object(a.b)("a",o({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"addmodify-content-in-the-collection-view"})),Object(a.b)("a",o({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#addmodify-content-in-the-collection-view"}),"#"),"Add/Modify content in the collection view"),Object(a.b)("h4",null,Object(a.b)("a",o({parentName:"h4"},{"aria-hidden":!0,className:"anchor",id:"changeset-api"})),Object(a.b)("a",o({parentName:"h4"},{"aria-hidden":!0,className:"hash-link",href:"#changeset-api"}),"#"),"Changeset API"),Object(a.b)("p",null,"Using ",Object(a.b)("inlineCode",{parentName:"p"},"CKCollectionViewDataSource")," changes are never applied directly to the collection. Instead, commands are sent to the datasource and from those commands will be used to compute the components and apply the corresponding changes to the collection view."),Object(a.b)("p",null,"Let's add a section at index 0 with two items at indexes 0 and 1."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-objectivec"}),"- (void)viewDidAppear:(BOOL)animated {\n  [super viewDidAppear:animated];\n  ...\n  CKDataSourceChangeset *initialChangeset =\n  [[[[CKDataSourceChangesetBuilder dataSourceChangeset]\n    withInsertedSections:[NSIndexSet indexSetWithIndex:0]] // Don't forget the insertion of section 0\n      withInsertedItems:@{[NSIndexPath indexPathForItem:0 inSection:0] : firstModel,\n      [NSIndexPath indexPathForItem:1 inSection:0] : secondModel}] build];\n  [self.dataSource applyChangeset:initialChangeset mode:CKUpdateModeAsynchronous userInfo:nil;\n}\n")),Object(a.b)("p",null,"Later on (for instance when updated data is received from the server), we can update our first item with an updated model."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-objectivec"}),"...\nCKDataSourceChangeset *updateChangeset =\n[[[CKDataSourceChangesetBuilder dataSourceChangeset] withUpdatedItems:@{[NSIndexPath indexPathForItem:0 inSection:0] : updatedFirstModel}] build];\n[self.dataSource applyChangeset:updateChangeset mode:CKUpdateModeAsynchronous userInfo:nil];\n...\n")),Object(a.b)("p",null,"It is also possible to remove items and sections through this ",Object(a.b)("a",o({parentName:"p"},{href:"/docs/datasource-changeset-api"}),"changeset API"),"."),Object(a.b)("h4",null,Object(a.b)("a",o({parentName:"h4"},{"aria-hidden":!0,className:"anchor",id:"layout"})),Object(a.b)("a",o({parentName:"h4"},{"aria-hidden":!0,className:"hash-link",href:"#layout"}),"#"),"Layout"),Object(a.b)("p",null,"As you can see above a ",Object(a.b)("em",{parentName:"p"},"constrained size")," is passed every time a changeset is enqueued, this constrained size is used internally to layout the components and compute their final sizes which will have to be within those top-level constraints."),Object(a.b)("p",null,"The form of the constrained size is: {% raw  %}",Object(a.b)("inlineCode",{parentName:"p"},"{{minWidth, minHeight},{maxWidth, maxHeight}}"),"{% endraw %}."),Object(a.b)("p",null,"Let's see how the computed component sizes can be used with the ",Object(a.b)("inlineCode",{parentName:"p"},"UICollectionViewFlowLayout"),", for the purpose of this example let's assume that the view controller is the delegate of the flow layout."),Object(a.b)("p",null,"Each item is sized so that it matches the size of its corresponding component."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-objectivec"}),"- (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout *)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath {\n    return [self.dataSource sizeForItemAtIndexPath:indexPath];\n}\n")),Object(a.b)("p",null,"Pretty simple right ? And this logic can apply to any ",Object(a.b)("inlineCode",{parentName:"p"},"UICollectionViewLayout")," :"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"The datasource computes the size of the components within the top level constraint."),Object(a.b)("li",{parentName:"ul"},"Then those sizes can be used in a ",Object(a.b)("inlineCode",{parentName:"li"},"UICollectionViewLayout")," to size and position the corresponding items.")),Object(a.b)("h3",null,Object(a.b)("a",o({parentName:"h3"},{"aria-hidden":!0,className:"anchor",id:"handle-actions"})),Object(a.b)("a",o({parentName:"h3"},{"aria-hidden":!0,className:"hash-link",href:"#handle-actions"}),"#"),"Handle actions"),Object(a.b)("p",null,"Time to interact with those items now; nothing special here the regular selection APIs can be used. Let's say the models have a url that should be opened when the user tap on an item."),Object(a.b)("pre",null,Object(a.b)("code",o({parentName:"pre"},{className:"language-objectivec"}),"- (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath\n{\n    MyModel *model = (MyModel *)[self.dataSource modelForItemAtIndexPath:indexPath];\n    if (model.url != nil) {\n        [[UIApplication sharedApplication] openURL:navURL];\n    }\n}\n")),Object(a.b)("div",{class:"note-important"},Object(a.b)("p",null,"The datasource is the source of truth for the collection view, if you have to retrieve a model corresponding to an indexPath always use ",Object(a.b)("inlineCode",{parentName:"p"},"-modelForItemAtIndexPath"),". See this ",Object(a.b)("a",o({parentName:"p"},{href:"/docs/datasource-gotchas"}),"gotcha")," for more details.")))}d.isMDXComponent=!0}}]);
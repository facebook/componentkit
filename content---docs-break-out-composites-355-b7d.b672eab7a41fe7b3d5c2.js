(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{63:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",function(){return r}),t.d(n,"rightToc",function(){return p}),t.d(n,"default",function(){return m});t(0);var o=t(133);function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e}).apply(this,arguments)}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},s=Object.keys(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)t=s[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var r={title:"Break Out Composite Components"},p=[{value:"Stateless Component",id:"stateless-component",children:[]},{value:"Composite Components",id:"composite-components",children:[]}],i={rightToc:p},c="wrapper";function m(e){var n=e.components,t=s(e,["components"]);return Object(o.b)(c,a({},i,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Donâ€™t be afraid to split components into smaller components. Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a label, a rounded profile picture: all those are commonly expressed as components."),Object(o.b)("h2",null,Object(o.b)("a",a({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"stateless-component"})),Object(o.b)("a",a({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#stateless-component"}),"#"),"Stateless Component"),Object(o.b)("p",null,"The simplest way to declare a component is to create a ",Object(o.b)("inlineCode",{parentName:"p"},"CKStatelessComponent"),". A ",Object(o.b)("inlineCode",{parentName:"p"},"CKStatelessComponent")," is based on the concept of purity in functional programming paradigms, meaning that it renders the same output for the same input (in this case ",Object(o.b)("inlineCode",{parentName:"p"},"props"),") with no need of a ",Object(o.b)("inlineCode",{parentName:"p"},"state")," dependency."),Object(o.b)("pre",null,Object(o.b)("code",a({parentName:"pre"},{className:"language-objectivec"}),"struct NewComponentProps {\n  UIEdgeInsets insets;\n}\n\nCKComponent *NewComponent(const NewComponentProps &props)\n{\n  return CKCreateStatelessComponent(\n          [CKInsetComponent\n            newWithInsets:props.insets\n            component:[AwesomeComponent new]],\n          __func__); // __func__ is used to easily identify your stateless component in DEBUG\n}\n")),Object(o.b)("p",null,"Stateless component are optimized to have the minimum memory and binary size impact and lifts off the need of making all of your components an Objective-C class."),Object(o.b)("h2",null,Object(o.b)("a",a({parentName:"h2"},{"aria-hidden":!0,className:"anchor",id:"composite-components"})),Object(o.b)("a",a({parentName:"h2"},{"aria-hidden":!0,className:"hash-link",href:"#composite-components"}),"#"),"Composite Components"),Object(o.b)("p",null,"When your component depends on an internal state that is used to render its content you can create your new component as subclass of ",Object(o.b)("a",a({parentName:"p"},{href:"composite-components"}),"`CKCompositeComponent"),"."))}m.isMDXComponent=!0}}]);